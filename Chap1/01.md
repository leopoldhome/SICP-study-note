# Chap1

##  前言

> 这门课最重要的并不是lisp语言本身，而是一种通用的框架体系。所以，这门课也叫做"元语言抽象"。

在第一章的时候，作者建立了最基本的思路，也是本书的基调。这本书并不是要整个程序和系统的设计，主要的思路如下：

1. 黑盒抽象	  Black-box abstraction
2. 约定接口      conventional interface
3. 元语言抽象  metalinguistic abstraction

  sussman教授在1.1The Element of Programming中首先提到了：***一个强大的语言一定要包含如下的三种机制***：

1. 基本表达式 [^ ①] ：

   [^①]:基本表达式的意思就是值我们常规的 加、减、乘、除、余数等等，等等的操作；

2. 基本组合：这里我们可以把组合理解为完成了某一个功能的一些数学表达式，一堆括号的集合；

   ```lisp
   ;;完成了一些数据的处理，达到了一定的目的；
   (+ 3 5)
   ;; 较第一个例子完成了一些复杂的操作；计算出了某一个具体的数值；
   ;; 按照书中的描述，就是构造出了一些复杂的单元 compound elements are built fro simpler ones.
   (/ 2.0 (+ x (/ (+ x y) 2)))
   ```

3. 抽象的方法：所谓抽象，我们其实可以把它理解为构造出了一些对象，通过书中的过程[^procedure] 。我们可以对他进行命名，把它当做一个对象（高级语言就是对象了）或者  "unit"一个完整的单元或者功能块去操作，其实我们要做了也就是去调用这种功能块而已。

   我的理解在这里是：

   ```lisp
   ;;如下的这个就是一个组合,完成的就是一个cube的立方操作
   (* 3 3 3)
   (* 4 4 4)
   ;;但是在以上的一个层面上，我们无法对功能进行重用。所以，我们构建了一个cube的抽象
   (define (cube x) (* x x x)
   ```



​     在1.3节中有一个非常经典的抽象。使用的是定积分的模型；如何采用一套模型，只是在更改里面函数的情况下，如何最优构建出这个过程。
$$
\int_a^b x^2 {\rm d}x； \int_a^b x {\rm d}x
$$

> 注意：在本文中，作者不断的在提出过程这个概念。所有的过程包装成一个black-box就得到了一个unit。这个unit。本书的过程一直在不断的逼近如何对功能进行构建。包括对数学的理解。比如说我们马上就要提到的平方根。
>
> 我们在整个程序中，是在考虑如何通过过程的迭代，去获取到我们的输出是什么；而不是向现在的高级语言，我们直接调用某一个接口，就能够得到最终的结果。

### 复合过程的计算模型



### 黑盒抽象

这里使用的是牛顿平方根的一个案例。1.17的开头说的非常清楚。数学和计算机过程之间有一个重要差异，那就是，这一过程必须是可行的，有效的。数学关心的是如何进行描述，而计算机关心的是如何做，具体到这里就是采用了过程的方式，进行抽象，通过不断的算法逼近，获取到一个数的平方根。

* 如下的牛顿方法是一个标准的通过wishfull thinking去获取到输出的案例。我到底想干什么，通过一个靠谱的设想，慢慢的、自然的分解为一个个的子问题。我们可能就获取到了最终的结果。

```lisp
#lang planet neil/sicp
;; 定义绝对值的组合
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x)))
  )

(define (abs-if x)
  (if (< x 0)
      (- x)
      x))
(define (cube x) (* x x x))

;;1.1.7 采用牛顿法来找出一个书的平方根
;;我们依然采用了一种wishfull thiking的方式。
;; 猜测一个值，如果这个值已经足够好，那么这个值就直接使用， Work is Done；但是如果这个值不够精确，就不断的improve；
;;所以，sqrt-iter过程不断的在接收guess值，x值；即guess值在迭代中
(define (sqrt-iter guess x)
  (if (good-enough? guess x)   
      guess
      (sqrt-iter (improve guess x) x)))

;; 猜测就是x 和x/y的平均值；对improve的过程以及相关子过程进行定义
(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

;; 再定义什么叫足够好
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
;; 定义平方根
(define (square x) (* x x))
;; 最后，把这个猜测的过程做一个封装，变成一个black-box
(define (sqrt x)
  (sqrt-iter 1.0 x))
```

但是针对大型的程序来说，以上的过程定义，都是可以理解为全局定义。可能其他的程序也使用了相同的名字，这样，就会导致困惑。因此，作为一个black-box，我们希望可能把它完全的作为一个unit来呈现。这样我们就用到了内部定义和块结构。

### 递归和迭代

```lisp
;; 计算阶乘，有两种方法。具备不同的时间和空间复杂度
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
;; Solution2 是一种通过迭代的方法来进行计算
(define (factoria-iter n)
   (define (fact-iter product counter max-count)
   (if (> counter max-count)
       product
       (fact-iter (* product counter)
                  (+ counter 1)
                  max-count)))
;  (fact-iter 1 1 n)
  )
```



```lisp
;;Fabonacci数列

```

### 两个例子（汉诺塔+零钱兑换算法）
 这两个例子都是非常经典的不断缩小问题规模的案例；
 ```lisp
 ;;汉诺塔，重点是思考如何缩小问题的规模；
 
 ```

+ 零钱兑换的问题

  ![image](https://github.com/leopoldhome/Pic/blob/main/coin_change.png)

  从这个图，我们可以发现，对于零钱问题。我们要缩小规模，最主要的问题就是分解的规模是不能重叠的。

  所以，我们考虑

  

